---
title: "Exploring Low-Cost DIY Rockets with Flight Recording using 3D Printing and Low-Cost Sensors"
subtitle: "Design, Launch, Data Analysis, and Lessons Learned"
author: "Jannes Kaspar-Müller"
date: "`r Sys.Date()`"
output:
  
  pdf_document:
    latex_engine: xelatex  # or lualatex
    toc: false
    citation_package: biblatex
    number_sections: true
    fig_width: 10
    fig_height: 6
    fig_caption: true
    df_print: kable
    extra_dependencies: ["float"]
  html_document:
    toc: true
    number_sections: true

header-includes:
  - \usepackage[style=apa]{biblatex}
  - \addbibresource{references.bib}
  - \usepackage{etoolbox}
  - \pretocmd{\printbibliography}{\addcontentsline{toc}{section}{References}}{}{}
  
bibliography: references.bib 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.pos = "H", out.extra = "")
```

![Constructed rocket during liftoff](title-picture.jpeg)
\pagebreak

```{=latex}
% Trigger ToC creation in LaTeX
\tableofcontents
\pagebreak
\listoffigures
\pagebreak
```

```{r loading, echo=FALSE, warning=FALSE, message=FALSE, results='hide'}
source("dataPreperation.R")
```

# Goals

3D printed
Fit multiple motors
Record as much flight data as possible for "cheap"

\newpage

# Design

The design section is divided into three parts. The first covers the rocket's overall design, detailing its structure and components. The second explains the simulations conducted to evaluate the rocket's expected performance and stability. The final part outlines the features of the flight recorder and the key decisions made during its development.

## Rocket Structure

The rocket follows a traditional hobbyist design, featuring a single motor located at the base with no active guidance system \autocite{nasa_model_rockets_2024}. To ensure stability during flight, fins are positioned at the bottom. Additionally, since the rocket is intended for recovery, the nosecone must be detachable, triggered by the ejection charge from the motor. This requires the ejection blast to travel the full length of the rocket to the nosecone without damaging the on-board electronics responsible for recording flight data.
Based on these goals, the following decisions were made regarding the design and manufacturing of the rocket:


### The Case for 3D Printing

Due to the goals of affordability and easy of manufacturing the decision to use 3D printing to manufacture as many pieces of the rockets as possible was made. 
3D printing allows anybody with access to the 3D model of the rocket to produce it nearly identical. 
The widespread adoption of 3D printing for hobby projects made printers as well as filament widely available, cheap to obtain and easy use.
Therefore the rocket can not only be replicated with low complexity for the builder but also at a minimal cost or effort involved \autocite{pearce2022economic}.
Additionally the process of 3D printing allows to easily build geometries that would usually be hard or expensive to machine or produce at small production volumes and scales \autocite{berman20123, berman2020managing}.
Specifically FDM 3D printing was used to build the complete Rocket structure.

### Selected Materials

Different 3D printing filaments offer different strength or density properties that might be more beneficial to use on different parts of the rocket \autocite{bambu_filament_guide_2024}. The most used hobbyist Filament, PLA, is an all rounder, offering good toughness, strength, stiffness, layer adhesion and ease of printing for a low price per kilogram. For this reason, PLA was chosen as the default material for most parts of the rocket that aren't subjected to high forces or extreme temperatures. 

The option of printing certain components in more expensive, ultra-lightweight filaments like ASA Aero (ASA infused with a temperature-activated foaming agent) was considered. However, this approach was ultimately set aside due to the reduced strength and increased printing complexity, which limits the ability to create intricate designs to some extent.

There are 2 parts on the rocket that required further consideration before selecting the filament:
\begin{enumerate}
  \item The fins of a rocket are often quite thin and stick out of the rocket body often making contact first when impacting during soft landings or transportation. Therefore the 
  \item asdf asdfasd fasdfas d.asdf asdfa dafsdfasdfa sdfa.sdf asdfasd fasdfasdfas df.asdf asdfas df  adsfasdfasd. adsfasdf asdf asdf asdf asdfa.afsdf asdfas dfasdf asdf asd f.
\end{enumerate}



## Performance & Stability Simulations
## Flight Recording System

\newpage

# Launch

In this chapter I will first analyse the launch based on the data the various sensors recorded.
Following that I will compare the actual measurements with the result of the simulation.
This chapter concludes with a failure analysis that summarizes all encountered issues and investigates their root causes, aiming to prevent similar and related failures in the future.

## Data Analysis

The data analysis will first take a look at each sensors individual measurement.
At the end the data of multiple sensors will be combined to get a more comprehensive understanding of the flight and to compare performance as well as accuracy of sensors.

### Pressure Sensor

The primary function of the barometric pressure sensor is to measure the rocket's altitude throughout its flight. 
With an accuracy of approximately ±8 Pa, it can determine altitude to within ±0.5 m \autocite{dfrobotGravityBMP388}.
Since each point in the following figure represents the difference between the initial ground measurement and the reading at that specific moment, the cumulative accuracy adjusts to about ±1m — still providing a very reliable measurement.
Additionally locally weighted scatterplot smoothing (LOWESS) has been used to plot an additional curve that is less susceptible to the minor variations in the sensors measurements.

```{r pressure-alt, echo=FALSE, fig.cap="Altitude as measured by the barometric pressure sensor", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  # Map the converted seconds to the x-axis
  geom_line(aes(y = Altitude.Lowess, color = "Pressure LOWESS"), size = 1, linetype = "solid") +
  geom_line(aes(y = Altitude, color = "Pressure")) +
  
  # Highlight the top-most point with a horizontal line to the y-axis
  geom_segment(aes(x = min(Seconds), xend = max_seconds, y = max_alt_value, yend = max_alt_value), 
               linetype = "dashed", color = "blue", size = 0.3) +  # Dashed line to the y-axis
  
  geom_point(aes(x = max_seconds, y = max_alt_value), color = "blue", size = 2) +  # Highlight the max point with a dot
  
  # Add a label for the maximum point with adjusted positioning
  annotate("text", x = max_seconds, y = max_alt_value, label = paste("Max: ", max_alt_value,"m ±1m", sep = ""), 
           color = "blue", vjust = 1.5, hjust = 2) +  # Adjusted to prevent leaving plot area
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +  
  scale_color_manual(values = c("Pressure" = "grey40", "Pressure LOWESS" = "red")) +
  labs(x = "Time (s:ms)", y = "Altitude (in m)", color = NULL) +  # Add x-axis label as "Time"
  scale_y_continuous(breaks = seq(0, max(track$Altitude, na.rm = TRUE), by = 25)) +  # Set y-axis breaks to steps of 25
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        legend.position = c(0.75, 0.12)) + # Adjust position inside plot 
  labs(title = "Altitude", 
          subtitle = "Based on BMP388 pressure measurements ±1m",
          caption = "Pathfinder launch 2024-09-29")
```
The data shows a steep ascent between 1:00 and 2:00 followed by a slow increase until the peak of 134.47m is reached at 7:00.
At this point all upwards velocity is lost due to gravity and friction.
Gravity now continues to accelerate the rocket towards the ground again. 
Since the rocket moves faster and faster towards the ground it becomes apparent that the parachute system failed.
The ejection charge was supposed to release the parachute at roughly 8:00 but the nose did not manage to seperate causing the rocket to impact the ground without slowing down.

The sudden drop shortly after the peak is reached (or perhaps covering the timeframe where the peak was really reached) is quite interesting to see.
It’s difficult to determine whether this dip is due to measurement error occurring coincidentally at this time, or if the rocket encountered a unique pressure phenomenon at its peak
Additional flights might bring more insight if this is merely a correlation or if this is actually caused be the rocket reaching its peak.
Perhaps future flights might also profit from redundant sensors.


Using the altitude data, the gradient of altitude can be calculated to determine the rocket’s vertical speed.
While the barometric pressure recorded by the sensor might look smooth at a first glance it becomes apparent that the minimal variations in the sensors measurements result in huge spikes when calculating the gradient.
Calculating the gradient of the altitiude LOWESS yields a lot better and cleaner results that should still be very accurate since it only reduces the variation and doesnt alter the curves trajectory.
This graph shows that the maximum vertical speed was around 40 m/s.

```{r pressure-speed, echo=FALSE, fig.cap="Vertical Speed as measured by the barometric pressure sensor", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  # Map the converted seconds to the x-axis
  geom_line(aes(y = Altitude.Velocity.Lowess.Pracma, color = "Vertical speed based on altitude LOWESS"), size = 1, linetype = "solid") +
  geom_line(aes(y = Altitude.Velocity.Pracma, color = "Vertical speed based on measurements"))  +
  ylim(-65, 65) +
   
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +  
  scale_color_manual(values = c("Vertical speed based on measurements" = "grey40", "Vertical speed based on altitude LOWESS" = "red")) +
  labs(x = "Time (s:ms)", y = "Vertical speed (in m/s)", color = NULL) +  # Add x-axis label as "Time"
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        legend.position = c(0.75, 0.1)) + # Adjust position inside plot 
  labs(title = "Vertical speed", 
          subtitle = "Based on BMP388 pressure measurements",
          caption = "Pathfinder launch 2024-09-29")
```
Trying to calculate a gradient from either of the calculated vertical speeds yielded no usable results.
In this case even the variations of the LOWESS are to significant to produce usable data.
Perhaps calculating another LOWESS based on the Vertical speed LOWESS might produce nicer looking results but it is questionable how accurate those would still be.

```{r pressure-accel, echo=FALSE, fig.cap="Vertical Acceleration as measured by the barometric pressure sensor", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  # Map the converted seconds to the x-axis
  geom_line(aes(y = Altitude.Acceleration.Lowess.Pracma, color = "Acceleration LOWESS"), size = 1, linetype = "solid") +
  geom_line(aes(y = Altitude.Acceleration.Pracma, color = "Acceleration"))  +
  ylim(-60,60) +
  
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +  
  scale_color_manual(values = c("Acceleration" = "grey40", "Acceleration LOWESS" = "red")) +
  labs(x = "Time (s:ms)", y = "Acceleration (in m/s²)", color = NULL) +  # Add x-axis label as "Time"
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        legend.position = c(0.85, 0.1)) + # Adjust position inside plot 
  labs(title = "Rocket vertical acceleration", 
       subtitle = "Based on BMP388 pressure measurements",
       caption = "Pathfinder launch 2024-09-29")
```

The barometric pressure sensor is the perfect sensor for determining the altitude during the flight accurately.
The high velocity of the rocket does not seem to have decreased the quality of measurements except perhaps the sudden decrease and increase shortly after or during the peak of the rocket.
Variations in the individual measurements make it hard to calculate a gradient but using local regression it is possible to still determine the speed of the rocket during the launch.
The variations seem to be to high to calculate the acceleration of the rocket though which is a bummer since it would have been interesting to compare the vertical acceleration measured by the pressure sensor and the accelerometer.


### Accelerometer

The accelerometer recorded the acceleration of the rocket in 3 axis during the launch.
The most interesting axis is the vertical axis labeled with Y in the graphic below.
As expected the vertical acceleration matches the thrust curve of a D12-5 engine in shape and duration \autocite{estesD12} confirming the validity of measurements to some degree.

```{r accel-raw, echo=FALSE, fig.cap="Raw Acceleration as measured by the Accelerometer", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = Acceleration_X, color = "Acceleration X"), size = 0.7)  +
  geom_line(aes(y = Acceleration_Y, color = "Acceleration Y"), size = 0.7)  +
  geom_line(aes(y = Acceleration_Z, color = "Acceleration Z"), size = 0.7)  +
  
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Acceleration (in m/s²)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.3)) +
  labs(title = "Rocket raw acceleration", 
       subtitle = "Based on MPU6050 acceleration measurements",
       caption = "Pathfinder launch 2024-09-29")
```

While the general shape of the thrust might look okay and follow expectations a closer inspection shows that the accelerometer data is actually flawed.
During the period on the ground before lift-off there should have been a force of roughly 9.81 m/s² representing gravity.
Instead the total acceleration on all axis before liftoff was only 4.87-4.91m/s².
This seems to be pretty exactly half of the expected acceleration hinting at a scaling issue in either the library or the accelerometers scale factor that is calibrated at the factory.
Simply multiplying measured values by two yielded unsatisfactory results and it is very likely that poor understanding and integration of this sensor ahead of flight made the data unusable.

```{r accel-accel, echo=FALSE, fig.cap="Total Acceleration as measured by the Accelerometer", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = Acceleration_Total, color = "Acceleration"), size = 0.7)  +
  ylim(-15,60) +
  
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Acceleration (in m/s²)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket total acceleration", 
       subtitle = "Based on MPU6050 acceleration measurements",
       caption = "Pathfinder launch 2024-09-29")
```

Further flights must take a closer look at the accelerometer before launching, particularly ensuring that the expected acceleration of gravity is present before launch for the collected data to be trustworthy.
Also settings like the accelerometer range and filter bandwidth as well as other settings must be better understood before taking flight.
It might also make sense to compare multiple different libraries or reading the sensor directly to get all the raw data that can be processed after and not during the flight.

### Gyroscope

The angular speed measured by the gyroscope during the flight can be seen below.
It is immediatelly obvious that the rocket experienced the highest angular speed around its roll axis during the flight.

```{r gyro-raw, echo=FALSE, fig.cap="Rocket roll rotations during flight", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = Gyro_X, color = "Pitch"), size = 0.7)  +
  geom_line(aes(y = Gyro_Y, color = "Roll"), size = 0.7)  +
  geom_line(aes(y = Gyro_Z, color = "Yaw"), size = 0.7)  +
  
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Speed (in rad/s)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket roll rotations", 
       subtitle = "Based on MPU6050 gyro measurements",
       caption = "Pathfinder launch 2024-09-29")
```

As seen here the roll speed of the rocket was even greater than the limit of 500 deg/s.
This limit was arbitrarily chosen before the flight and options for 1000 deg/s as well as 2000 deg/s were also available.
The chart highlights that this limit was crossed in two intervals during the flight leading to the loss of data that could have been prevented with a better understanding of data ranges before the flight.
It also is visible, that the highest roll speed was achieved during ascent an descent of the rocket.

```{r gyro-roll-range, echo=FALSE, fig.cap="Measured roll compared to maximum range", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = 500, color = "Roll Range Maximum"), size = 0.7, alpha=0.5)  +
  geom_line(aes(y = Gyro_Y_deg, color = "Roll"), size = 0.7)  +
  
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Speed (in degree/s)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket roll compared to maximum", 
       subtitle = "Based on MPU6050 gyro measurements",
       caption = "Pathfinder launch 2024-09-29")

```

Overall the roll axis speed was quite high. 
Calculating the total amount of rotations by integrating the speed shows that the rocket did at least `r round(max(track$angle_Y_rotations), 2)` rotations in a timeframe of `r round(rotation_duration, 2)` seconds averaging 
`r round(round(max(track$angle_Y_rotations), 2) / round(rotation_duration, 2),2)` rotations per second.
Since roll data was lost the actual amount of rotations is assumed to be even higher.
This is significant because future rockets might have a camera attached to them.
A high roll rate will make the recorded footage during ascent and decent unusable.

```{r gyro-rotations, echo=FALSE, fig.cap="Amount of rotations around roll axis", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = track$angle_Y_rotations, color = "Amount of roll rotations"), size = 0.7)  +
  geom_point(aes(x = max(track$Seconds), y = max(track$angle_Y_rotations)), color = "blue", size = 2) +
  geom_segment(aes(x = min(track$Seconds), xend = max(track$Seconds), y = max(track$angle_Y_rotations), yend = max(track$angle_Y_rotations)), 
               linetype = "dashed", color = "blue", size = 0.3) +
  annotate("text", x = max(track$Seconds), y = max(track$angle_Y_rotations), label = paste(round(max(track$angle_Y_rotations),1)," rotations in total", sep = ""), 
          color = "blue", vjust = 1.5, hjust = 2) +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Count", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket angular speed", 
       subtitle = "Based on MPU6050 gyro measurements",
       caption = "Pathfinder launch 2024-09-29")
```

Even though this rocket did not use any active steering method the gyro measurements still provided valuable data.
Understanding the stability of the rocket during the flight is crucial for further rocket builds.
A later graphic will also show the rocket orientation during the flight.
Once again the sensor and the expected values were poorly understood before the launch.
This resulted in the choice for an insufficient measurement range leading to the loss of some roll data.

### GPS

An error in the flight recorder software caused it not to record the amount of visible satellites during the launch.
This would have been interesting data to have to compare signal accuracy with different numbers of satellites.
Additionally only the horizontal dilution of precision (HDOP) was tracked since the used library did not include the vertical dilution of precision (VDOP) by default.
In hindsight this data would still have been relevant and should be recorded for future launches.

The chart below shows the HDOP during the flight on a logarithmic scale.
The `r high_hdop_end-high_hdop_start`s period with a very high HDOP is noticeable and will also be highlighted in following graphics that might require horizontal precision.

```{r gps-hdop, echo=FALSE, fig.cap="GPS horizontal dilution of precision", warning=FALSE}
ggplot(track, aes(x = Seconds)) + 
  geom_line(aes(y = GPS_HDOP, color = "GPS HDOP"), size = 0.7, linetype = "solid") +
  scale_y_continuous(trans='log10') +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "HDOP", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = c(0.85, 0.05)) +
  labs(title = "GPD horizontal dilution of precision", 
       subtitle = "Based on BE-220 GPS, log y scale",
       caption = "Pathfinder launch 2024-09-29")
```

The total speed of the rocket as tracked by the gps is very inaccurate with big jumps and does not match the actual flight path or the data obtained by the barometric pressure sensor a lot.
The brief period with high HDOP seems to have no influence on the tracked speed.

```{r gps-measured-speed, echo=FALSE, fig.cap="Total speed measured by GPS", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_rect(aes(xmin = high_hdop_start, xmax = high_hdop_end, ymin = -Inf, ymax = Inf), fill="#ffa50001") +
  geom_line(aes(y = GPS_Speed_ms, color = "Speed"), size = 0.7)  +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Speed (in m/s)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  
        legend.position = c(0.85, 0.1)) + 
  labs(title = "Rocket total speed", 
       subtitle = "Based on BE-220 GPS measurements",
       caption = "Pathfinder launch 2024-09-29")
```

The altitude data recorded by the gps seems to have a very strong delay.
It first measured a noticeable ascent of the rocket 5 seconds after the actual launch.

```{r gps-measured-altitude, echo=FALSE, fig.cap="Altitude measured by GPS", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  # Map the converted seconds to the x-axis
  geom_line(aes(y = GPS_Altitude.Adjusted, color = "Altitude"), size = 0.7) +
  
  # Highlight the top-most point with a horizontal line to the y-axis
  geom_segment(aes(x = min(Seconds), xend = max_seconds_gps, y = max_alt_value_gps, yend = max_alt_value_gps), 
               linetype = "dashed", color = "blue", size = 0.3) +  # Dashed line to the y-axis
  
  geom_point(aes(x = max_seconds_gps, y = max_alt_value_gps), color = "blue", size = 2) +  # Highlight the max point with a dot
  
  # Add a label for the maximum point with adjusted positioning
  annotate("text", x = max_seconds, y = max_alt_value_gps, label = paste("Max: ", max_alt_value_gps,"m ±1m", sep = ""), 
           color = "blue", vjust = 1.5, hjust = 2) +  # Adjusted to prevent leaving plot area
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +  
  labs(x = "Time (s:ms)", y = "Altitude (in m)", color = NULL) +  # Add x-axis label as "Time"
  scale_y_continuous(breaks = seq(0, max(track$GPS_Altitude.Adjusted, na.rm = TRUE), by = 25)) +  # Set y-axis breaks to steps of 25
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        legend.position = c(0.75, 0.12)) + # Adjust position inside plot 
  labs(title = "Altitude", 
       subtitle = "Based on BE-220 GPS measurements",
       caption = "Pathfinder launch 2024-09-29")
```

The most interesting data recorded by the GPS is most likely the 2D position of the rocket.
No other sensor on the rocket was capable of measuring the data.
The following chart shows the path of the rocket as seen from above.
This also shows that there was quite a big jump in the recorded gps data.
It is unlikely that the rocket actually flew exactly this path.


```{r gps-2d, echo=FALSE, fig.cap="2D position of rocket based on GPS", warning=FALSE}
ggplot(data = track_unique, aes(x = GPS_Longitude, y = GPS_Latitude)) + 
  geom_segment(aes(xend = lead(GPS_Longitude), yend = lead(GPS_Latitude), 
                   color = Altitude), 
               arrow = arrow(length = unit(0.15, "cm")),  
               alpha = 1,
               size = 0.8) +
  scale_color_gradientn(colors = c("darkgreen", "olivedrab", "goldenrod", "darkgoldenrod", "red"),
                        limits = c(0, 140), 
                        oob = scales::squish,
                        name = "Altitude") +  
  labs(x = "Longitude", y = "Latitude") +     
  theme_minimal() + 
  labs(title = "2D position of rocket", 
       subtitle = "Based on BE-220 GPS",
       caption = "Pathfinder launch 2024-09-29")


```

Calculating the horizontal distance covered by the rocket based on the individual gps 2D positions yields the grey curve.
Using the lowess it is possible to exclude the sudden jump caused by the gps mid-flight.
Using the previous chart and this one it becomes apparent that the rocket covered a lot more horizontal ground during ascent than descent.


```{r gps-horizontal-distance, echo=FALSE, fig.cap="Horizontal distance of rocket based on GPS", warning=FALSE}
ggplot(track, aes(x = Seconds)) + 
  geom_rect(aes(xmin = high_hdop_start, xmax = high_hdop_end, ymin = -Inf, ymax = Inf), fill="#ffa50001") +
  geom_line(aes(y = Total.Distance.Horizontal.Lowess, color = "Distance Lowess"), size = 1, linetype = "solid") +
  geom_line(aes(y = Total.Distance.Horizontal, color = "Distance"), size = 0.7)  +
  scale_color_manual(values = c("Distance" = "grey40", "Distance Lowess" = "red")) +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Distance (in m)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = c(0.85, 0.1)) + 
  labs(title = "Horizontal Distance", 
       subtitle = "Based on BE-220 GPS",
       caption = "Pathfinder launch 2024-09-29")

```

Using the gradient to calculate the horizontal speed also highlights the previous conclusion.
Although this once again highlights that calculating the gradient of even LOWESS smoothened only approximates the real speed with a high variance.

```{r gps-horizontal-speed, echo=FALSE, fig.cap="Horizontal speed of rocket based on GPS", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = GPS_Total_Horizontal_Speed, color = "Horizontal Speed"), size = 0.7)  +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Speed (in m/s)", color = NULL) +  
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  
        legend.position = c(0.85, 0.1)) + 
  labs(title = "Horizontal Speed", 
       subtitle = "Based on BE-220 GPS",
       caption = "Pathfinder launch 2024-09-29")
```

Overall the gps measured some unique data like the absolute position of the rocket and the 2D track of the rocket.
Altitude and speed measurements seem to be inaccurate though and the gps seems to have quite a high delay at times.
The 2D position of the rocket often was redundant with multiple measurements having the same coordinates.
Additionally there was a sudden jump in gps positions decreasing the quality of the data a lot.
For future launches it should be checked if there are setting to decrease jumps or the delay.


## Combining measurements

The previous chapters only looked at the data measured by individual sensors.
The goal of this chapter is to explore if combining and enhancing data collected by different sensors will result in new insights.
This also makes it possible to compare the quality of data recorded by different sensors.

Gps and barometric pressure sensor are both capable of measuring the rockets altitude during the flight.
The following graphic shows the altitude measured by the GPS in green and the barometric altitude in blue.
It is obvious that the gps data contains a lot more jumps and it seems to be delayed by quite a bit.
The red line syncs barometric pressure and gps at their respective peaks.
While peak measured by the gps is only off by 13.13 ±1m the data overall doesnt describe the ascent of the rocket very well.
Moving forward the altitude measured by the barometric pressure sensor will be used when determining the altitude of the rocket.

```{r gps-baro-altitude-comparison, echo=FALSE, fig.cap="Comparison of GPS and barometer altitude measurements", warning=FALSE}
ggplot(track, aes(x = Seconds)) + 
  geom_line(aes(y = GPS_Altitude.Adjusted, color = "Altitude GPS (unsynced)"), size = 0.5, linetype = "solid") +
  geom_line(aes(y = GPS_Altitude.Adjusted.NoDelay, color = "Altitude GPS (synced with peak)"), size = 0.7, linetype = "solid") +
  geom_line(aes(y = Altitude, color = "Altitude pressure sensor"), size = 0.7)  +
  geom_segment(aes(x = max_seconds, xend = max_seconds, y = max_alt_value_gps, yend = max_alt_value), 
               linetype = "dashed", color = "black", size = 0.6) +  
  geom_point(aes(x = max_seconds, y = max_alt_value_gps), color = "red", size = 2) +  
  geom_point(aes(x = max_seconds, y = max_alt_value), color = "blue", size = 2) + 
  annotate("text", x = max_seconds, y = max_alt_value + abs(max_alt_value_gps - max_alt_value) / 2, label = paste(abs(max_alt_value_gps - max_alt_value),"m", sep = ""), 
           color = "black", vjust = 0.75, hjust = 1.2) +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Distance (in m)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = c(0.85, 0.1)) + 
  labs(title = "Altitude measurement comparison", 
       subtitle = "Based on BE-220 GPS and BMP388 measurements",
       caption = "Pathfinder launch 2024-09-29")

```

Using the altitude measured by the pressure sensor and the 2D position measured by the gps makes it possible to approximate the flight path of the rocket in 3D.

```{r gps-baro-3d, echo=FALSE, fig.cap="3D position of rocket based on GPS and Barometer data", warning=FALSE, fig.show='hold',fig.align='center', out.height="35%"}
chart <- plot_ly(track_unique, 
                 x = ~GPS_Longitude, 
                 y = ~GPS_Latitude, 
                 z = ~Altitude,  
                 type = 'scatter3d', 
                 mode = 'lines+markers',  
                 line = list(width = 2, color = ~Altitude, colorscale = 'Viridis'),  
                 marker = list(size = 4, color = ~Altitude, colorscale = 'Viridis')) %>%
  layout(scene = list(xaxis = list(title = 'Longitude'),
                      yaxis = list(title = 'Latitude'),
                      zaxis = list(title = 'Altitude'),
                      camera = list(
                        eye = list(x = -2, y = 1, z = .5), 
                        up = list(x = 0, y = 0, z = 1),  
                        center = list(x = 0, y = 0, z = 0)  
                      )))


chart2 <- plot_ly(track_unique, 
                 x = ~GPS_Longitude, 
                 y = ~GPS_Latitude, 
                 z = ~Altitude,  
                 type = 'scatter3d', 
                 mode = 'lines+markers', 
                 line = list(width = 2, color = ~Altitude, colorscale = 'Viridis'), 
                 marker = list(size = 4, color = ~Altitude, colorscale = 'Viridis')) %>%
  layout(scene = list(xaxis = list(title = 'Longitude'),
                      yaxis = list(title = 'Latitude'),
                      zaxis = list(title = 'Altitude'),
                      camera = list(
                        eye = list(x = -1, y = -1, z = 2),  
                        up = list(x = 0, y = 0, z = 2),
                        center = list(x = 0, y = 0, z = 0) 
                      )))


# Save the widget to an HTML file
htmlwidgets::saveWidget(widget = chart, file = "tmp/gps3d-1.html")
htmlwidgets::saveWidget(widget = chart2, file = "tmp/gps3d-2.html")

# Take a screenshot of the HTML file to save as PNG
discard <- webshot2::webshot("tmp/gps3d-1.html", file = "tmp/gps3d-1.png", vwidth = 800, vheight = 800, zoom = 2)
discard <- webshot2::webshot("tmp/gps3d-2.html", file = "tmp/gps3d-2.png", vwidth = 800, vheight = 800, zoom = 2)



knitr::include_graphics(c("tmp/gps3d-1.png","tmp/gps3d-2.png"))
```

Based on this 3D flight path it is possible to calculate the total distance covered by the rocket.

```{r gps-baro-distance, echo=FALSE, fig.cap="Total distance covered by rocket based on GPS and Barometer", warning=FALSE}
ggplot(track, aes(x = Seconds)) + 
  geom_line(aes(y = Total.Distance.Lowess, color = "Distance LOWESS"), size = 0.7, linetype = "solid") +
  geom_line(aes(y = Total.Distance, color = "Distance"), size = 0.7)  +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Distance in m", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket total distance covered", 
       subtitle = "Based on BE-220 GPS and BMP388 pressure measurements",
       caption = "Pathfinder launch 2024-09-29")
```

And by calculating the gradient of that the total speed of the rocket can be calculated.
Previous speed measurements were mostly horizontal or vertical speed, making this chart as the rockets true speed quite interesting.
This shows how combining gps and barometric data can result in a new understanding of the rocket during flight.

```{r gps-baro-speed, echo=FALSE, fig.cap="Total speed of rocket based on GPS and Barometer", warning=FALSE}
ggplot(track, aes(x = Seconds)) + 
  geom_line(aes(y = GPS_Baro_Total_Speed, color = "Speed"), size = 0.7)  +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Speed (in m/s)", color = NULL) +  
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket total speed", 
       subtitle = "Based on BE-220 GPS and BMP388 pressure measurements",
       caption = "Pathfinder launch 2024-09-29")

```

```{r gps-baro-speed-overlay, echo=FALSE, fig.cap="Total speed of rocket compared to vertical speed", warning=FALSE}
ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = GPS_Baro_Total_Speed, color = "Total speed (pressure + gps)"), size = 0.7)  +
  geom_line(aes(y = Altitude.Velocity.Lowess.Pracma.Abs, color = "Total vertical speed (pressure only)"), size = 0.7)  +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", y = "Speed (in m/s)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) + 
  labs(title = "Rocket total speed compared", 
       subtitle = "Based on BE-220 GPS and BMP388 pressure measurements",
       caption = "Pathfinder launch 2024-09-29")
```

Using the data of multiple sensors can also explain the nature of the high roll rate mentioned earlier.
The total speed calculated above and the roll rate have a correlation of `r round(cor(track$GPS_Baro_Total_Speed, track$Gyro_Y),digits =3)`.
Therefore they are strongly correlated.
The chart below uses two different scales with a scale factor to highlight this relationship.
This data points to an asymmetric geometry of the rocket causing uneven drag at high speeds.
Most likely this is due to the fins not aligning perfectly and being at a slight angle.


```{r speed-roll, echo=FALSE, fig.cap="Correlation between speed and roll", warning=FALSE}

scale_factor <- 4.5  

ggplot(track, aes(x = Seconds)) +  
  geom_line(aes(y = GPS_Baro_Total_Speed, color = "Rocket total speed"), size = 0.7) +
  geom_line(aes(y = Gyro_Y * scale_factor, color = "Roll"), size = 0.7) +  
  
  scale_y_continuous(
    name = "Speed (in m/s)",
    sec.axis = sec_axis(~./scale_factor, name = "Gyro Y (in rad/s)") 
  ) +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +
  labs(x = "Time (s:ms)", color = NULL) + 
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) +
  labs(title = "Rocket angular speed", 
       subtitle = paste("Correlation between roll and speed: ", 
                        round(cor(track$GPS_Baro_Total_Speed, track$Gyro_Y),digits =3)),
       caption = "Pathfinder launch 2024-09-29")

```

The rockets orientation during the flight can also be displayed by using the barometric pressure sensors altitude and the rockets orientation measured by the gyro sensor.
It is important to note that the x-axis here does not track distance but time.

```{r gyro-angle, echo=FALSE, fig.cap="Rocket rotation during flight", warning=FALSE}
arrow_data <- track %>%
  slice(seq(1, n(), by = 5)) %>%
  mutate(
    x_end = Seconds - 0.25 * sin(angle_X),
    y_end = Altitude + 5 * cos(angle_X)
  )

# Plot with arrows instead of lines
ggplot(track, aes(x = Seconds)) +
  geom_segment(data = arrow_data,
               aes(xend = x_end, y = Altitude, yend = y_end, color = "Rocket Orientation"),
               arrow = arrow(type = "closed", length = unit(0.1, "inches")),
               size = 1, linetype = "solid") +
  scale_x_continuous(breaks = pretty(track$Seconds, n = 10), labels = seconds_milliseconds) +  
  labs(x = "Time (s:ms)", y = "Altitude (in m)", color = NULL) +  # Add x-axis label as "Time"
  scale_y_continuous(breaks = seq(0, max(track$Altitude, na.rm = TRUE), by = 25)) +  # Set y-axis breaks to steps of 25
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        legend.position = c(0.75, 0.12)) + # Adjust position inside plot 
  labs(title = "Rocket orientation", 
       subtitle = "Based on BMP388 pressure measurements and MPU6050 angle measurements",
       caption = "Pathfinder launch 2024-09-29")
```

## Comparison with simulation

```{r simulation-altitude, echo=FALSE, fig.cap="Simulated altitude compared with measured altitude", warning=FALSE}
ggplot(comparison, aes(x = Seconds.y)) +  
  geom_line(aes(y = SimulatedAltitude, color = "Simulated Altitude"), size = 0.7) +
  geom_line(aes(y = Altitude, color = "Measured Altitude"), size = 0.7) +
  labs(x = "Time (s:ms)", y = "Altitude (in m)", color = NULL) +  
  theme_minimal() +
  scale_x_continuous(breaks = pretty(comparison$Seconds.y, n = 10), labels = seconds_milliseconds) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        legend.position = c(0.75, 0.12)) + 
  labs(title = "Simulation altitude comparison", 
       subtitle = "Based on BMP388 pressure measurements and simulation",
       caption = "Pathfinder launch 2024-09-29")
```

```{r simulation-acceleration, echo=FALSE, fig.cap="Simulated vertical acceleration compared with measured acceleration", warning=FALSE}
ggplot(comparison, aes(x = Seconds.y)) +  
  geom_line(aes(y = Acceleration_Y -  4.81, color = "Measured Acceleration"), size = 0.7)  +
  geom_line(aes(y = SimulatedVerticalAcceleration, color = "Simulated Acceleration"), size = 0.7)  +
  labs(x = "Time (s:ms)", y = "Acceleration (in m/s²)", color = NULL) + 
  theme_minimal() +
  scale_x_continuous(breaks = pretty(comparison$Seconds.y, n = 10), labels = seconds_milliseconds) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = c(0.85, 0.1)) +
  labs(title = "Simulated acceleration comparison", 
       subtitle = "Based on MPU6050 acceleration measurements and simulation",
       caption = "Pathfinder launch 2024-09-29")

```

## Failure Analysis - Parachute, SD-Card, GPS VDOP and satellites

\newpage

# Conclusion
## Critical Reflection
## Next steps

\newpage

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE, dpi=500, fig.cap="This is my plot"}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot  
